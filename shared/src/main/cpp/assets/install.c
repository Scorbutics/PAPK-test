#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <errno.h>
#include <unistd.h>
#include <libgen.h>

#ifdef HAS_EMBEDDED_DATA
#include "mz.h"
#include "mz_zip.h"
#include "mz_strm.h"
#include "mz_strm_mem.h"
#include "mz_zip_rw.h"

// External symbols from embedded files (generated by objcopy)
extern const char _binary_ruby_stdlib_zip_start[];
extern const char _binary_ruby_stdlib_zip_end[];
extern const char _binary_fifo_interpreter_rb_start[];
extern const char _binary_fifo_interpreter_rb_end[];
extern const char _binary_ruby_physfs_patch_rb_start[];
extern const char _binary_ruby_physfs_patch_rb_end[];

// Helper function to create directories recursively
static int create_directories(const char *path) {
    char *path_copy = strdup(path);
    char *dir = dirname(path_copy);

    struct stat st = {0};
    if (stat(dir, &st) == -1) {
        // Try to create parent directories first
        if (create_directories(dir) != 0) {
            free(path_copy);
            return -1;
        }

        if (mkdir(dir, 0755) != 0 && errno != EEXIST) {
            fprintf(stderr, "Failed to create directory %s: %s\n", dir, strerror(errno));
            free(path_copy);
            return -1;
        }
    }

    free(path_copy);
    return 0;
}

// Extract a zip file from memory to a directory
static int extract_zip_from_memory(const char *zip_data, size_t zip_size, const char *extract_dir) {
    void *zip_handle = NULL;
    void *stream = NULL;
    int32_t err = MZ_OK;
    mz_zip_file *file_info = NULL;
    char extract_path[1024];
    FILE *output_file = NULL;
    void *buf = NULL;
    int32_t buf_size = 8192;
    int32_t bytes_read = 0;

    // Create memory stream
    stream = mz_stream_mem_create();
    if (!stream) {
        fprintf(stderr, "Failed to create memory stream\n");
        return -1;
    }

    mz_stream_mem_set_buffer(stream, (void*)zip_data, zip_size);

    // Create zip reader
    zip_handle = mz_zip_reader_create();
    if (!zip_handle) {
        fprintf(stderr, "Failed to create zip reader\n");
        goto cleanup;
    }

    // Open zip from memory stream
    err = mz_zip_reader_open(zip_handle, stream);
    if (err != MZ_OK) {
        fprintf(stderr, "Failed to open zip from memory: %d\n", err);
        goto cleanup;
    }

    // Go to first entry
    err = mz_zip_reader_goto_first_entry(zip_handle);
    if (err != MZ_OK && err != MZ_END_OF_LIST) {
        fprintf(stderr, "Failed to go to first zip entry: %d\n", err);
        goto cleanup;
    }

    buf = malloc(buf_size);
    if (!buf) {
        fprintf(stderr, "Failed to allocate buffer\n");
        err = MZ_MEM_ERROR;
        goto cleanup;
    }

    // Extract all entries
    do {
        err = mz_zip_reader_entry_get_info(zip_handle, &file_info);
        if (err != MZ_OK) {
            fprintf(stderr, "Failed to get zip entry info: %d\n", err);
            goto cleanup;
        }

        // Skip directories (check if filename ends with '/')
        if (file_info->filename[strlen(file_info->filename) - 1] == '/') {
            snprintf(extract_path, sizeof(extract_path), "%s/%s", extract_dir, file_info->filename);
            // Remove trailing slash
            extract_path[strlen(extract_path) - 1] = '\0';
            if (mkdir(extract_path, 0755) != 0 && errno != EEXIST) {
                fprintf(stderr, "Failed to create directory %s: %s\n", extract_path, strerror(errno));
                // Continue with other files
            }
        } else {
            // Extract file
            snprintf(extract_path, sizeof(extract_path), "%s/%s", extract_dir, file_info->filename);

            // Create parent directories
            if (create_directories(extract_path) != 0) {
                fprintf(stderr, "Failed to create parent directories for %s\n", extract_path);
                goto next_entry;
            }

            // Open entry for reading
            err = mz_zip_reader_entry_open(zip_handle);
            if (err != MZ_OK) {
                fprintf(stderr, "Failed to open zip entry %s: %d\n", file_info->filename, err);
                goto next_entry;
            }

            // Open output file
            output_file = fopen(extract_path, "wb");
            if (!output_file) {
                fprintf(stderr, "Failed to create file %s: %s\n", extract_path, strerror(errno));
                mz_zip_reader_entry_close(zip_handle);
                goto next_entry;
            }

            // Read and write file data
            do {
                bytes_read = mz_zip_reader_entry_read(zip_handle, buf, buf_size);
                if (bytes_read < 0) {
                    fprintf(stderr, "Error reading from zip entry: %d\n", bytes_read);
                    break;
                }
                if (bytes_read > 0) {
                    if (fwrite(buf, 1, bytes_read, output_file) != (size_t)bytes_read) {
                        fprintf(stderr, "Error writing to file %s: %s\n", extract_path, strerror(errno));
                        break;
                    }
                }
            } while (bytes_read > 0);

            fclose(output_file);
            output_file = NULL;

            mz_zip_reader_entry_close(zip_handle);

        }

next_entry:
        err = mz_zip_reader_goto_next_entry(zip_handle);
    } while (err == MZ_OK);

    if (err == MZ_END_OF_LIST) {
        err = MZ_OK; // Normal end of entries
    }

cleanup:
    if (buf) free(buf);
    if (output_file) fclose(output_file);
    if (zip_handle) {
        mz_zip_reader_close(zip_handle);
        mz_zip_reader_delete(&zip_handle);
    }
    if (stream) {
        mz_stream_mem_delete(&stream);
    }

    return (err == MZ_OK) ? 0 : -1;
}

// Write binary data to a file
static int write_binary_file(const char *filename, const char *data, size_t size) {
    // Create parent directories
    if (create_directories(filename) != 0) {
        return -1;
    }

    FILE *file = fopen(filename, "wb");
    if (!file) {
        fprintf(stderr, "Failed to create file %s: %s\n", filename, strerror(errno));
        return -1;
    }

    size_t written = fwrite(data, 1, size, file);
    fclose(file);

    if (written != size) {
        fprintf(stderr, "Failed to write complete data to %s\n", filename);
        return -1;
    }

    printf("Created: %s (%zu bytes)\n", filename, size);
    return 0;
}

// Main installation function
int install_embedded_files(const char *install_dir) {
    char full_path[1024];
    int result = 0;

    if (!install_dir) {
        fprintf(stderr, "Install directory cannot be NULL\n");
        return -1;
    }

    printf("Installing embedded files to: %s\n", install_dir);

    // Create base installation directory
    if (mkdir(install_dir, 0755) != 0 && errno != EEXIST) {
        fprintf(stderr, "Failed to create install directory %s: %s\n", install_dir, strerror(errno));
        return -1;
    }

    // Extract Ruby standard library ZIP
    printf("Extracting Ruby standard library...\n");
    size_t ruby_stdlib_size = _binary_ruby_stdlib_zip_end - _binary_ruby_stdlib_zip_start;
    if (mkdir(install_dir, 0755) != 0 && errno != EEXIST) {
        fprintf(stderr, "Failed to create ruby-stdlib directory: %s\n", strerror(errno));
        result = -1;
    } else {
        if (extract_zip_from_memory(_binary_ruby_stdlib_zip_start, ruby_stdlib_size, install_dir) != 0) {
            fprintf(stderr, "Failed to extract Ruby standard library\n");
            result = -1;
        }
    }

    // Write FIFO interpreter Ruby file
    printf("Installing FIFO interpreter...\n");
    size_t fifo_interpreter_size = _binary_fifo_interpreter_rb_end - _binary_fifo_interpreter_rb_start;
    snprintf(full_path, sizeof(full_path), "%s/fifo_interpreter.rb", install_dir);
    if (write_binary_file(full_path, _binary_fifo_interpreter_rb_start, fifo_interpreter_size) != 0) {
        fprintf(stderr, "Failed to install FIFO interpreter\n");
        result = -1;
    }

    // Write Ruby PhysFS patch file
    printf("Installing Ruby PhysFS patch...\n");
    size_t physfs_patch_size = _binary_ruby_physfs_patch_rb_end - _binary_ruby_physfs_patch_rb_start;
    snprintf(full_path, sizeof(full_path), "%s/ruby_physfs_patch.rb", install_dir);
    if (write_binary_file(full_path, _binary_ruby_physfs_patch_rb_start, physfs_patch_size) != 0) {
        fprintf(stderr, "Failed to install Ruby PhysFS patch\n");
        result = -1;
    }

    if (result == 0) {
        printf("Installation completed successfully!\n");
    } else {
        printf("Installation completed with errors.\n");
    }

    return result;
}

// Convenience function to get default install directory (can be customized)
const char* get_default_install_dir(void) {
    static char install_dir[1024];
    const char *cache_dir = getenv("XDG_CACHE_HOME");

    if (!cache_dir) {
        const char *home = getenv("HOME");
        if (home) {
            snprintf(install_dir, sizeof(install_dir), "%s/.cache/your_app", home);
        } else {
            // Fallback for Android or systems without HOME
            snprintf(install_dir, sizeof(install_dir), "/tmp/your_app_install");
        }
    } else {
        snprintf(install_dir, sizeof(install_dir), "%s/your_app", cache_dir);
    }

    return install_dir;
}

// Function to check if installation is needed (files exist and are valid)
int installation_needed(const char *install_dir) {
    char check_path[1024];
    struct stat st;

    // Check if key files exist
    snprintf(check_path, sizeof(check_path), "%s/fifo_interpreter.rb", install_dir);
    if (stat(check_path, &st) != 0) return 1;

    snprintf(check_path, sizeof(check_path), "%s/ruby_physfs_patch.rb", install_dir);
    if (stat(check_path, &st) != 0) return 1;

    snprintf(check_path, sizeof(check_path), "%s/ruby-stdlib", install_dir);
    if (stat(check_path, &st) != 0) return 1;

    return 0; // Installation not needed
}

#else // !HAS_EMBEDDED_DATA

int install_embedded_files(const char *install_dir) {
    fprintf(stderr, "No embedded data available. Library was compiled without HAS_EMBEDDED_DATA.\n");
    return -1;
}

const char* get_default_install_dir(void) {
    return NULL;
}

int installation_needed(const char *install_dir) {
    return -1;
}

#endif // HAS_EMBEDDED_DATA
